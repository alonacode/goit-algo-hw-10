


# Завдання 1
##Задача розміну монет — Жадібний підхід та Динамічне програмування
Програма розв’язує класичну задачу видачі решти для набору монет:

COINS = [50, 25, 10, 5, 2, 1]

Є дві реалізації:

1. **Greedy (жадібний алгоритм)**  
   Швидко знаходить розв’язок, беручи найбільші можливі монети.  
   Для "канонічних" наборів (як у прикладі) гарантує мінімальну кількість монет.

2. **Dynamic Programming (Динамічне програмування, DP)**  
   Використовує метод динамічного програмування для знаходження справді мінімальної кількості монет навіть для неканонічних систем.

---

## Приклад запуску

```bash
$ python3 task1.py
Amount to give change: 113
Greedy  : {50: 2, 10: 1, 2: 1, 1: 1}
DP (min): {1: 1, 2: 1, 10: 1, 50: 2}
```
## Порівняння алгоритмів

- **Greedy**:
  - Часова складність: $O(k)$
  - Працює майже миттєво, навіть для великих сум.
  - Може дати неоптимальне рішення, якщо набір монет неканонічний.

- **DP**:
  - Часова складність: $O(\text{amount} \cdot k)$
  - Завжди знаходить мінімальну кількість монет.
  - Повільніше при великих значеннях `amount`.

## Вимірювання часу (timeit)

Приклад для `amount = 113`:

| Алгоритм | best (ms/call) | avg (ms/call) |
|----------|----------------|---------------|
| Greedy   | 0.0010         | 0.0011        |
| DP (min) | 0.0784         | 0.0839        |

#Висновок

Жадібний алгоритм працює у десятки разів швидше, але обидва дають однаковий результат для канонічних монет.




# Завдання 2 — Інтегрування методом Монте-Карло

## Мета
Програмно реалізувати алгоритм пошуку визначеного інтеграла за допомогою методу Монте-Карло, 
а також порівняти результат з еталонним обчисленням за допомогою `scipy.integrate.quad` та аналітичним розв’язанням.

## Функція
- $f(x) = x^2$
- Інтервал інтегрування: $[0, 2]$

## Результати

### 1. Аналітичне обчислення
Інтеграл  
$$
\int_0^2 x^2 dx = \frac{8}{3} \approx 2.6667
$$

### 2. SciPy quad
2.666666666667 (reported abs err ~ 2.96e-14)


### 3. Метод Монте-Карло (mean-value)

| N       | MC     | MC−exact | Відн. помилка |
|--------:|-------:|---------:|--------------:|
| 1,000   | 2.6816 | 0.0149   | 0.56%         |
| 10,000  | 2.6652 | 0.0015   | 0.06%         |
| 100,000 | 2.6675 | 0.0008   | 0.03%         |
| 500,000 | 2.6668 | 0.0001   | 0.00%         |


Абсолютна похибка зменшується приблизно як  
$$
\frac{1}{\sqrt{N}}
$$

### 4. Багаторазові експерименти (50 запусків × 10 000 точок)
- Середній результат: 2.6670  
- Стандартне відхилення: 0.0105  
- Абс. помилка: 0.0003 (0.01%)

## Висновки
1. Метод Монте-Карло дає результат, що збігається з аналітичним та `quad` у межах статистичної похибки.  
2. Похибка зменшується зі зростанням кількості точок за законом $1/\sqrt{N}$.  
3. Для одновимірних інтегралів метод `quad` є точнішим та швидшим, однак метод Монте-Карло корисний для багатовимірних інтегралів та складних областей.

---

**Встановлення та запуск:**
```bash
pip3 install numpy scipy
python task2.py
